<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Basic Use &mdash; xHARPy 0.1.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Constraints" href="library_symm_con.html" />
    <link rel="prev" title="Scripting with xHARPy" href="library_index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> xHARPy
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../commandline.html">Command Line Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="library_index.html">Scripting with xHARPy</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Basic Use</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#loading-your-data">Loading your data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setting-options">Setting options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#refinement">Refinement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#writing-data-to-disk">Writing data to disk</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="library_symm_con.html">Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="library_refinement_dict.html">Refinement Options</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">xharpy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xharpy.html">xharpy package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../xharpy.f0j_sources.html">xharpy.f0j_sources package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">xHARPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="library_index.html">Scripting with xHARPy</a> &raquo;</li>
      <li>Basic Use</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/library/library_basis.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="basic-use">
<h1>Basic Use<a class="headerlink" href="#basic-use" title="Permalink to this headline"></a></h1>
<p>This is a commented step-by-step guide for the usage of xHARPy as a python
library. I try to also give some understanding what is happening. If you just
want results fast, I would suggest you adapt the L-alanin_gpaw example to your
structure. The examples folder is also very useful to look at applications after
you have a basic understanding of what is happening.</p>
<p>The imports here are split up according to the section, but of you would usually
still put all of them at the top of a .py or .ipynb file.</p>
<p>The usage of xHARPy as a to write refinement scripts can be split into four
distinct steps: Loading your data, setting refinement and computation options,
refinement and writing your data to disk.</p>
<div class="section" id="loading-your-data">
<h2>Loading your data<a class="headerlink" href="#loading-your-data" title="Permalink to this headline"></a></h2>
<p>For structures without atoms on special positions you just need a .cif and an
.hkl file. If you have atom on special positions, which require restraints, the
easiest way is to adapt these from a SHELXL .lst file</p>
<p>So let us import the io functions</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xharpy</span> <span class="kn">import</span> <span class="n">shelxl_hkl2pd</span><span class="p">,</span> <span class="n">cif2data</span><span class="p">,</span> <span class="n">lst2constraint_dict</span>
</pre></div>
</div>
<p>As written before the last one is only strictly necessary if we have atoms
on special positions. On the other hand it will also give the correct empty
dictionary if there are no constaints resulting from special positions, so I
usually just import it anyway.</p>
<p>Let us load the data from the cif-file using the cif2data function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">atom_table</span><span class="p">,</span> <span class="n">cell</span><span class="p">,</span> <span class="n">cell_esd</span><span class="p">,</span> <span class="n">symm_mats_vecs</span><span class="p">,</span> <span class="n">symm_strings</span><span class="p">,</span> <span class="n">wavelength</span>  <span class="o">=</span> <span class="n">cif2data</span><span class="p">(</span><span class="s1">&#39;iam.cif&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Let us first talk about the arguments of the function: The first one is simply
the path to our cif file. The second argument can either be an integer or a
string and can be used to select a specific data block within the .cif file.
We have used an integer, which the function will interpret as an index. So we
are selecting the first dataset. If we give a string we select the dataset by
name. So the string needs to match whatever is written behind <code class="docutils literal notranslate"><span class="pre">data\_</span></code> keyword
in the cif file.</p>
<p>From our function we have got a number of results, we need to further process.
Most importantly we have created an <code class="docutils literal notranslate"><span class="pre">atom_table</span></code>, which contains all our atomic
data in a pandas DataFrame. The columns are shortened versions of the naming in
the loop instruction. They are shortened by omitting the common beginning that
is unique to each table in a cif file. If values have an esd in the cif file
is is output to <code class="docutils literal notranslate"><span class="pre">&lt;column_name&gt;_esd</span></code>. Missing values are represented by a numpy
nan value. The <code class="docutils literal notranslate"><span class="pre">atom_table</span></code> can be manipulated to change values (especially the
adp type and parameters before we start our refinemen)</p>
<p>cell and cell_esd are just arrays containing the cell parameters and their
estimated standard deviations. The wavelength is a float with the wavelength.
<code class="docutils literal notranslate"><span class="pre">symm_mats_vecs</span></code> is a tuple containing the symmetry matrices and translation
vectors for the symmetry elements in the cif file. The <code class="docutils literal notranslate"><span class="pre">symm_strings</span></code> are
the corresponding strings.</p>
<p>Next let us load the reflection information with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">hkl</span> <span class="o">=</span> <span class="n">shelxl_hkl2pd</span><span class="p">(</span><span class="s1">&#39;iam.hkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Which will again return a pandas DataFrame, which has the columns: h, k, l,
intensity and int_esd, where the last is the estimated standard deviation of
the measured intensities.</p>
<p>Finally, for dealing with special position constraints we need a <code class="docutils literal notranslate"><span class="pre">constraint_dict</span></code>.
As mentioned before we can generate this one from an .lst file. If you have
hydrogen atoms on special positions, these need to be anisotropic in the run of
SHELXL that has been used for the .lst generation. Usually, you would want to
fix the hydrogen (or all atoms) with AFIX 1 before you run that refinement.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">constraint_dict</span> <span class="o">=</span> <span class="n">lst2constraint_dict</span><span class="p">(</span><span class="s1">&#39;iam.lst&#39;</span><span class="p">)</span>
<span class="c1"># constraint_dict = {} # This is also possible if there are no atoms on special positions</span>
</pre></div>
</div>
<p>A constraint_dict is a nested Dict. The syntax is explained in a separate page
about <a class="reference internal" href="library_symm_con.html"><span class="doc">symmetry constraints</span></a>.</p>
</div>
<div class="section" id="setting-options">
<h2>Setting options<a class="headerlink" href="#setting-options" title="Permalink to this headline"></a></h2>
<p>In general there are two type of options represented by their own dictionaries.
Options that concern the refinement routine and options that concern the
computation routines that calculate the atomic form factors.</p>
<p>A basic example for a <code class="docutils literal notranslate"><span class="pre">refinement_dict</span></code> would look like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">refinement_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;f0j_source&#39;</span><span class="p">:</span> <span class="s1">&#39;gpaw&#39;</span><span class="p">,</span> <span class="c1"># GPAW with single-core</span>
    <span class="c1">#&#39;f0j_source&#39;: &#39;gpaw_mpi&#39;, # GPAW with multi-core</span>
    <span class="s1">&#39;core&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="c1"># treatment of the core density</span>
    <span class="s1">&#39;extinction&#39;</span><span class="p">:</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="c1"># Refinement of extinction</span>
    <span class="s1">&#39;reload_step&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="c1"># step where the density is reloaded from the save_file, 1 means first step AFTER initialisation</span>
<span class="p">}</span>
</pre></div>
</div>
<p>You might notice that two of the options concern the computation of the
atomic form factors. The <code class="docutils literal notranslate"><span class="pre">f0j_source</span></code> is used to actually select the
implementation of the atomic form factor calculation within the refinement
routine. The implementations are also unaware of the step in the refinement.
The refinement itself triggers the reloading of a precalculated density.
We want to start from a new density, but after initialisation we want to reload
previous calculation to speed things up. We also want to calculate core density
on a separate spherical grid, as they have sharp maxima at the core positions.
This might not be well described on the rectangular grid we use for the valence
density. This also means Hirshfeld partitioning will not affect the core density.
There are more options for the <code class="docutils literal notranslate"><span class="pre">refinement_dict</span></code>, which are explained on a
<a class="reference internal" href="library_refinement_dict.html"><span class="doc">separate page</span></a>.</p>
<p>Next we need to define the options for the atomic form factor calculation. these
are directly passed on to the routines that we loaded with the f0j_source. An
example the selected GPAW source and a molecular structure might look like this:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">computation_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># options for the xHARPy implementation</span>
    <span class="s1">&#39;save_file&#39;</span><span class="p">:</span> <span class="s1">&#39;gpaw_result.gpw&#39;</span><span class="p">,</span> <span class="c1"># Where are results saved and loaded</span>
    <span class="s1">&#39;gridinterpolation&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="c1"># density interpolation to use for Hirshfeld and FFT</span>

    <span class="c1"># options that are passed on to the gpaw calculator</span>
    <span class="s1">&#39;xc&#39;</span><span class="p">:</span> <span class="s1">&#39;SCAN&#39;</span><span class="p">,</span> <span class="c1"># Functional</span>
    <span class="s1">&#39;txt&#39;</span><span class="p">:</span> <span class="s1">&#39;gpaw.txt&#39;</span><span class="p">,</span> <span class="c1"># Text output for GPAW</span>
    <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="mf">0.175</span><span class="p">,</span> <span class="c1"># Grid spacing for wavefunction calculation</span>
    <span class="s1">&#39;convergence&#39;</span><span class="p">:{</span><span class="s1">&#39;density&#39;</span><span class="p">:</span> <span class="mf">1e-7</span><span class="p">},</span> <span class="c1"># Higher convergence for density calculation</span>
    <span class="s1">&#39;symmetry&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;symmorphic&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span> <span class="c1"># Also search for symmetry involving translation</span>
    <span class="s1">&#39;nbands&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span> <span class="c1"># Number of calculated bands = n(occ) + 2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you can see the function of the GPAW source will read the options that are
specific to the xHARPy GPAW plugin and remove it from the dictionary. All options
that are not known will be passed on to the GPAW calculator without any further
checks. Options for the calc_f0j function can be found in the specific docstrings or
here in the xharpy.f0j_sources page. GPAW options can be found in the
<a class="reference external" href="https://wiki.fysik.dtu.dk/gpaw/documentation/basic.html">GPAW documentation</a></p>
</div>
<div class="section" id="refinement">
<h2>Refinement<a class="headerlink" href="#refinement" title="Permalink to this headline"></a></h2>
<p>For refinement we need to import two additional functions</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xharpy</span> <span class="kn">import</span> <span class="n">create_construction_instructions</span><span class="p">,</span> <span class="n">refine</span>
</pre></div>
</div>
<p>As mentioned on the introduction xHARPy uses JAX to automatically generate
gradients. However, we want to have one object that can map an array of
parameters to the properties of the atoms within the unit cell. Because of the
implementation in JAX, using just-in-time compiling, that object has to be
immutable. We get it and starting values for the parameters by calling the
<code class="docutils literal notranslate"><span class="pre">create_construction_instructions</span></code> function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">construction_instructions</span><span class="p">,</span> <span class="n">parameters</span> <span class="o">=</span> <span class="n">create_construction_instructions</span><span class="p">(</span>
    <span class="n">atom_table</span><span class="o">=</span><span class="n">atom_table</span><span class="p">,</span>
    <span class="n">constraint_dict</span><span class="o">=</span><span class="n">constraint_dict</span><span class="p">,</span>
    <span class="n">refinement_dict</span><span class="o">=</span><span class="n">refinement_dict</span>
<span class="p">)</span>
</pre></div>
</div>
<p>As you see we also need to pass the constraint_dict from the first section, as
well as our refinement_dict in order to reserve additional parameters for things
like extinction.</p>
<p>Finally, we can call the refine function, to do our actual refinement:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">parameters</span><span class="p">,</span> <span class="n">var_cov_mat</span><span class="p">,</span> <span class="n">information</span> <span class="o">=</span> <span class="n">refine</span><span class="p">(</span>
    <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span>
    <span class="n">symm_mats_vecs</span><span class="o">=</span><span class="n">symm_mats_vecs</span><span class="p">,</span>
    <span class="n">hkl</span><span class="o">=</span><span class="n">hkl</span><span class="p">,</span>
    <span class="n">construction_instructions</span><span class="o">=</span><span class="n">construction_instructions</span><span class="p">,</span>
    <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
    <span class="n">wavelength</span><span class="o">=</span><span class="n">wavelength</span><span class="p">,</span>
    <span class="n">refinement_dict</span><span class="o">=</span><span class="n">refinement_dict</span><span class="p">,</span>
    <span class="n">computation_dict</span><span class="o">=</span><span class="n">computation_dict</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The refinement will always refine the scale factor first before the atomic
parameters are refined.</p>
<p>We get back a refined set of parameters, the variance-covariance matrix and
an additional dictionary that contains things that might be interesting (such as
starting and end time) and things that are needed for output (such as the atomic
form factor values or the shifts at the last step).</p>
</div>
<div class="section" id="writing-data-to-disk">
<h2>Writing data to disk<a class="headerlink" href="#writing-data-to-disk" title="Permalink to this headline"></a></h2>
<p>Finally we want to export our structures. There are three kinds of files that we
can write at the moment, and three functions that we need to import</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xharpy</span> <span class="kn">import</span> <span class="n">write_cif</span><span class="p">,</span> <span class="n">write_res</span><span class="p">,</span> <span class="n">write_fcf</span>
</pre></div>
</div>
<p>The <em>crystallographic information file</em> is a standard format for exchanging and
depositing crystallographic data. We can write such a file with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">write_cif</span><span class="p">(</span>
    <span class="n">output_cif_path</span><span class="o">=</span><span class="s1">&#39;xharpy.cif&#39;</span><span class="p">),</span>
    <span class="n">cif_dataset</span><span class="o">=</span><span class="s1">&#39;xharpy&#39;</span><span class="p">,</span>
    <span class="n">shelx_cif_path</span><span class="o">=</span><span class="s1">&#39;iam.cif&#39;</span><span class="p">,</span>
    <span class="n">shelx_dataset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span>
    <span class="n">cell_esd</span><span class="o">=</span><span class="n">cell_esd</span><span class="p">,</span>
    <span class="n">symm_mats_vecs</span><span class="o">=</span><span class="n">symm_mats_vecs</span><span class="p">,</span>
    <span class="n">hkl</span><span class="o">=</span><span class="n">hkl</span><span class="p">,</span>
    <span class="n">construction_instructions</span><span class="o">=</span><span class="n">construction_instructions</span><span class="p">,</span>
    <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
    <span class="n">var_cov_mat</span><span class="o">=</span><span class="n">var_cov_mat</span><span class="p">,</span>
    <span class="n">refinement_dict</span><span class="o">=</span><span class="n">refinement_dict</span><span class="p">,</span>
    <span class="n">computation_dict</span><span class="o">=</span><span class="n">computation_dict</span><span class="p">,</span>
    <span class="n">information</span><span class="o">=</span><span class="n">information</span>
<span class="p">)</span>
</pre></div>
</div>
<p>You might notice that we need an original cif file (the library was developed
wth SHELXL) to generate the new cif file. The reason is that the write-routine
does currently not calculate all values by itself. Additional values such as
crystal size can also be added to the original cif file and will be then copied
to the new one.</p>
<p>Fcf files can be written as fcf mode 4 or 6 with the two commands:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">write_fcf</span><span class="p">(</span>
    <span class="n">fcf_path</span><span class="o">=</span><span class="s1">&#39;xharpy.fcf&#39;</span><span class="p">,</span>
    <span class="n">fcf_dataset</span><span class="o">=</span><span class="s1">&#39;xharpy&#39;</span><span class="p">,</span>
    <span class="n">fcf_mode</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
    <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span>
    <span class="n">hkl</span><span class="o">=</span><span class="n">hkl</span><span class="p">,</span>
    <span class="n">construction_instructions</span><span class="o">=</span><span class="n">construction_instructions</span><span class="p">,</span>
    <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
    <span class="n">wavelength</span><span class="o">=</span><span class="n">wavelength</span><span class="p">,</span>
    <span class="n">refinement_dict</span><span class="o">=</span><span class="n">refinement_dict</span><span class="p">,</span>
    <span class="n">symm_strings</span><span class="o">=</span><span class="n">symm_strings</span><span class="p">,</span>
    <span class="n">information</span><span class="o">=</span><span class="n">information</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">write_fcf</span><span class="p">(</span>
    <span class="n">fcf_path</span><span class="o">=</span><span class="s1">&#39;xharpy_6.fcf&#39;</span><span class="p">,</span>
    <span class="n">fcf_dataset</span><span class="o">=</span><span class="s1">&#39;xharpy_6&#39;</span><span class="p">,</span>
    <span class="n">fcf_mode</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
    <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span>
    <span class="n">hkl</span><span class="o">=</span><span class="n">hkl</span><span class="p">,</span>
    <span class="n">construction_instructions</span><span class="o">=</span><span class="n">construction_instructions</span><span class="p">,</span>
    <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
    <span class="n">wavelength</span><span class="o">=</span><span class="n">wavelength</span><span class="p">,</span>
    <span class="n">refinement_dict</span><span class="o">=</span><span class="n">refinement_dict</span><span class="p">,</span>
    <span class="n">symm_strings</span><span class="o">=</span><span class="n">symm_strings</span><span class="p">,</span>
    <span class="n">information</span><span class="o">=</span><span class="n">information</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Both outputs will correct for extinction, but only fcf6 will correct the
observed reflections for dispersion effects. If you want to access the corrected
values for validation. Both functions return a pandas DataFrame.</p>
<p>For visualisation of the structure and the difference electron density is is
also helpful to write a SHELXL .res file. This can be done by:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">write_res</span><span class="p">(</span>
    <span class="n">out_res_path</span><span class="o">=</span><span class="s1">&#39;xharpy_6.res&#39;</span><span class="p">),</span>
    <span class="n">in_res_path</span><span class="o">=</span><span class="s1">&#39;iam.lst&#39;</span><span class="p">,</span>
    <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span>
    <span class="n">cell_esd</span><span class="o">=</span><span class="n">cell_esd</span><span class="p">,</span>
    <span class="n">construction_instructions</span><span class="o">=</span><span class="n">construction_instructions</span><span class="p">,</span>
    <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
    <span class="n">wavelength</span><span class="o">=</span><span class="n">wavelength</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Again we need a template res or lst file. Currently xHARPy has no way to divide
symmetry cards into those generated by a lattice centring or inversion symmetry
and those generated by other symmetry elements. Which would be necessary for
writing these files on its own.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="library_index.html" class="btn btn-neutral float-left" title="Scripting with xHARPy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="library_symm_con.html" class="btn btn-neutral float-right" title="Constraints" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Paul Niklas Ruth.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>